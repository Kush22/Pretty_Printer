%{

  #include <iostream>
  #include <string>
  using namespace std;

  #include "y.tab.h"		// importing the header file generated by YACC in LEX

  extern int if_count;		// variable for counting the number of IF's encountered by lexer
  extern int if_block_count;	// variable for checking whether a new block has started
  extern char c;		// character demarcating the beginning of new block
  extern int inblock;		// variable for checking we are inside a block or not
  extern int for_count;		// variable for counting the number of IF's encountered by lexer
  extern int for_block_count;	// variable for checking whether a new block has started
%}

%%

[ \t]*			{;}	// neglecting extra \t and spaces

#include[ \t]*\<[ \t]*  { 
			  yylval.sval = new string(yytext); //assigning the value to attribute token so that it can be used in YACC
                          return INCLUDE; 		    // Token returned to YACC
			}

"++"                    {  
			  yylval.sval = new string(yytext);
			  return PLUSPLUS; 
			}

"--"			{  
			  yylval.sval = new string(yytext);
			  return MINUSMINUS; 
			}

"for"[ \t]*\(		{
			 if(for_count == 0 && for_block_count == 0) //if the first IF of block encounterd
			    for_count = 1;
			  else
			    if( c == ';' && for_count != 0 )		// if the if is beginning of a new block but incremented because of lookahead
			    {
			      c = ' ';			// set the demarcation character to empty
			      for_block_count = 1;		// setting the block_count = 1 (flag for the extra if)
			    }
			    else
			      for_count++;		// a cascaded IF found so increment the count
			    
			    yylval.sval = new string("for (");
                            return FOR;
			}


>[ \n\t]* 		{ return HEAD_END; }   		    //multiple headers have leading \t & \n's

(stdio|string|conio|iostream|iomanip|time)".h" {  	    //pre-defined header files ending with .h
			  
			  yylval.sval = new string(yytext); //assigning the value to attribute token so that it can be used in YACC
                          return HEADER; 
			}



(int)[ \t]*(main\(\))   {  
			  yylval.sval = new string(yytext);
			  return MAIN; 
			}

"cin"                   {
			  yylval.sval = new string(yytext);
			  return CIN; 
			}

\>\>                    { 				// Matching the indirection operator ( >> )
			  yylval.sval = new string(yytext);
			  return IN; 
			}
  
"cout"			{
			  yylval.sval = new string(yytext);			  
			  return COUT;
			}

\<\<			{
			  yylval.sval = new string(yytext);
			  return OUT;
			}

"\{"                    {
			  yylval.sval = new string(yytext);
			  inblock++ ;			// '{' marks the beginning of a block 
			  return OPEN_CURLY; 
			}

"\}"                    {
			  yylval.sval = new string(yytext);
			  inblock--;			// '{' marks the ending of a block 
			  return CLOSE_CURLY;
			}

"\;"                    {
			  yylval.sval = new string(yytext);
			  return SEMICOLON;
			}

"else"                  { 
			  yylval.sval = new string(yytext);
                          c = ' ';			//setting the character marking the beginning of new block to ' '
                          return ELSE;
			}

"\)"                    { c = ' ';
			  yylval.sval = new string(yytext);
			  return CLOSE_BRACE;
			}
 

"if"[ \t]*\(            {
			  if(if_count == 0 && if_block_count == 0) //if the first IF of block encounterd
			    if_count = 1;
			  else
			    if( c == ';' && if_count != 0 )		// if the if is beginning of a new block but incremented because of lookahead
			    {
			      c = ' ';			// set the demarcation character to empty
			      if_block_count = 1;		// setting the block_count = 1 (flag for the extra if)
			    }
			    else
			      if_count++;		// a cascaded IF found so increment the count
			    
			    yylval.sval = new string("if (");
                            return IF;
			}

"\<"|"\>"|"<="|">="|"=="|"!="   {
			  yylval.sval = new string(yytext);
			  return ROP;
			}

[0-9]+                  { 
			   yylval.type_value.value = new string(yytext);  // this is a multi-attribute TOKEN
                           yylval.type_value.type = new string("int");	  // has both a value & a type
                           return VAL;
			}

[0-9]+\.[0-9]*|[0-9]*\.[0-9]+  {
			  yylval.type_value.value = new string(yytext);   // this is a multi-attribute TOKEN
                           yylval.type_value.type = new string("float");  // has both a value & a type
                          return VAL;
			}     

\'[a-z|A-Z|0-9]\'       {
			  yylval.type_value.value = new string(yytext);   // this is a multi-attribute TOKEN
                           yylval.type_value.type = new string("char");	  // has both a value & a type
                          return VAL;
			}

"int"|"char"|"float"|"void"   { 
			  yylval.sval = new string(yytext);
                          return TYPE;
			}

"="                     { return EQUAL;} 

"+"|"-"|"*"|"/"|"%"	{
			  yylval.sval = new string(yytext);
			  return OP;
			}

(return)[ \t]+"0;"      {      
			  yylval.sval = new string(yytext);
                          return RETURN;
			}

[a-z]+                  { 
			  yylval.sval = new string(yytext);
                          return ID;
			}

.                       {	// Anything that does not match the above regular definitions is sent to YACC as it is ( '.' matches everything)
			  std::cout <<yytext[0]<< "\n";
                          return yytext[0];
			}


%%


